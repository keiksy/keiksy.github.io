<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Keiksy&#39;s NotePad</title>
        <link>https://keiksy.me/</link>
        <description>Keiksy同学的技术博客</description>
        <generator>Hugo 0.65.3 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
        
        
        <lastBuildDate>Wed, 04 Mar 2020 17:00:52 +0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss+xml" href="https://keiksy.me/rss.xml" />
        
        
            <item>
                <title>Hello World!</title>
                <link>https://keiksy.me/posts/helloworld/</link>
                <guid isPermaLink="true">https://keiksy.me/posts/helloworld/</guid>
                <pubDate>Wed, 04 Mar 2020 16:59:31 +0800</pubDate>
                
                
                
                    <description><![CDATA[<p><em>我的个人博客上线了！</em></p>
<p>从2月24日写下第一行<code>Django</code>代码起，十天之后，我的<code>Hugo</code>博客终于上线了！</p>
<p>第一次产生写些什么的想法是在大二看了知乎上一个讲互联网内容分发的文章时产生的，文章提到现在的互联网上绝大多数人都是内容的消费者，而这样只输入不输出的习惯时间久了实际上会影响一个人的表达能力，当时的我已经感到自己的文字表达能力退化了不少<del>强过吗</del>，因此决心以后找一个地方存放自己的想法。</p>
<p>关于个人信息记录，我做过的尝试有知乎专栏（有点丑说实话），各式各样的笔记应用（我还买过一年的Bear高级会员订阅，虽然后面11个月根本就没有打开过了），始终感觉不够装逼。后来学习了包括Java SSM和<code>Django</code>在内的Web开发技术，开始打算自己写一个博客网站。于是2月24日开始看<a href="https://www.zmrenwu.com/courses/hellodjango-blog-tutorial/">教程</a>动手，选择了<code>Django</code>+阿里云主机+阿里云域名的组合，在奋战了8天以后，发现不会前端技术的我使用模板继承套出来的博客又丑又难用，在书写<code>Markdown</code>内容时还会产生奇怪的Bug，而且在VPS部署新的后台代码时Git各种各样的操作让人崩溃，最后阿里云域名备案时还产生了死锁：我的河北省身份证无法在我读书的湖南省备案，然而想在河北省备案又需要京津冀的手机号。不过总的说来，这次使用<code>Django</code>写博客的经历还是学会了不少东西：</p>
<ul>
<li>Django框架简单使用</li>
<li>Linux进一步学习和第一次实践：阅读了<code>The Linux Command Line</code>一书的大部分内容，学习了<code>Vim</code>编辑器的一些奇技淫巧</li>
<li>Git的重新学习和实践：阅读了<code>Pro Git</code>一书的部分章节</li>
<li>一些<code>Unix</code>工具学习：进程控制工具<code>supervisor</code>，Python HTTP服务器<code>Gunicorn</code>，反向代理服务器<code>Nginx</code></li>
<li>复习了一些计算机网络的基础知识并领略了这些知识的实际落地形式</li>
</ul>
<p>在解决一些<code>Django</code>博客问题的过程中，我发现了许多漂亮的个人博客，这些博客基本都是采用<code>Hexo</code>，<code>Hugo</code>等静态网页生成器生成静态页面然后部署在<code>GitHub Pages</code>上的方案，于是被上面奇奇怪怪问题困扰<del>懒</del>的我毅然采用了<code>Hugo</code>和<code>GitHub Pages</code>的方案，学习了一下午<code>Hugo</code>的使用方法以后，我发现这才是我想要的：简单，迅速，部署容易，即使不会前端的我也可以下载各种主题然后修改配置文件定制我的博客。</p>
<p>3月4日，我用了一个通宵的时间修改配置文件，用Python写了一个部署新博文的脚本，又在GoDaddy购买了新的域名<del>可怜了我11块在阿里云买的keiksy.tech</del>，然后按照这篇<a href="https://mogeko.me/2019/056/">博客</a>的方法，在Cloudflare上做了CDN，并搞了一个HTTPS<del>以提升逼格</del>，现在你看到的博客自豪地采用了<code>Hugo</code>主题<code>MemE</code>，网站标题栏的字体是<code>Euphoria</code>，我看到这个字体的第一眼就爱上了。接下来的打算是将之前写的一些算法题题解搬运到这边，并选择一些更合适的字体，宋体这么文艺的字体显然并不适合书写技术博客。</p>
<p>EOF</p>
]]></description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>TCP&RDP原理简述</title>
                <link>https://keiksy.me/posts/tcprdp%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/</link>
                <guid isPermaLink="true">https://keiksy.me/posts/tcprdp%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/</guid>
                <pubDate>Wed, 04 Mar 2020 04:41:04 +0800</pubDate>
                
                
                
                    <description><![CDATA[<h1 id="rdt--tcp">RDT &amp; TCP</h1>
<p>本文总结了可靠数据传输协议（RDT）和传输控制协议（TCP）的原理和工作方法，主要参考了《自顶向下》。</p>
<h1 id="可靠数据传输原理">可靠数据传输原理</h1>
<h2 id="为什么需要rdt协议">为什么需要RDT协议？</h2>
<p>RDT位于运输层，其下方的网络层，链路层均不是可靠的，在下面的层上传输数据，数据可能会丢失（丢包），可能会损坏（bit翻转），也可能会乱序发送。为了保证上层应用层的应用程序能够正常地工作，需要在运输层构建可靠的数据传输协议，保证接收方得到的数据的完整和正确。</p>
<p>下面，我们会从最完美的假设开始构建RDT协议，再逐步地模拟真实通信的情况，进而完善RDT协议。</p>
<h2 id="本文的约定">本文的约定</h2>
<p>在发送方，应用层通过rdt_send()调用rdt协议传输数据，运输层通过udt_send()调用网络层发送数据。</p>
<p>在接收方，运输层通过rdt_rcv()调用网络层接收数据，运输层再通过deliver_data操作将确认的报文传给应用层协议。</p>
<p>应用层使用AL（Application Layer）表示，运输层使用TL（Transportation Layer）表示，网络层使用NL（Network Layer）表示。</p>
<p>1，2，3，4等序号表明一次网络通信过程中双方交互的动作顺序。</p>
<h2 id="rdt-10">RDT 1.0</h2>
<p>RDT 1.0对于底层信道的假设是完全可靠的，因此不需要设计任何附加的措施来保证数据可靠传输。</p>
<p><strong>发送方</strong>：当应用层准备好发送数据时，只需调用rdt_send()传给运输层，运输层直接加上报文头发给网络层。</p>
<p><strong>接收方</strong>：当网络层收到数据时，只需调用rdt_rcv()传给运输层，运输层直接多路分解发送给应用层。</p>
<h2 id="rdt-2-series">RDT 2 Series</h2>
<p>RDT 2 Series假设分组中的位可能受损，导致数据损坏。但是还是不会丢包。</p>
<h3 id="rdt-20">RDT 2.0</h3>
<p>考虑一个生活中的例子：A给B打电话，B准确地收到了A的消息后会说“OK”（用ACK信号表示），示意A继续说，如果A说了一句模糊不清的话，B会说“没听清”（用NAK信号表示），示意A重说一遍刚才的话。这里的ACK和NAK就是两个控制报文，控制报文可以让发送方知道哪些内容被正确接收，哪些内容接收有误并且需要重传。</p>
<p>在计算机网络中，进行位差错检测有多种算法，这些算法通常会在报文上附加几个检测位，并且这些算法从数学上保证了正确。</p>
<p><strong>发送方</strong>：</p>
<p>1.AL调用rdt_send()后，TL生成运输层报文，然后调用udt_send()发给NL。然后发送方开始等待接收方的控制报文。</p>
<p>3.如果收到ACK报文，转回1，如果收到NAK报文，重传数据包，直到收到ACK为止。</p>
<p><strong>接收方</strong>：</p>
<p>2.NL收到数据，调rdt_rcv()发给运输层，然后运输层检测数据位错误，如果没错，发送ACK报文给发送方，如果有错，发送NAK报文给发送方。</p>
<p>当发送方收到接收方的控制报文之前，不可以发送下一个数据，只能等着，因此RDT 2.0是一个停等协议。</p>
<h3 id="rdt-21">RDT 2.1</h3>
<p>在RDT 2.0中，没有考虑到ACK和NAK控制报文受损的情况，我们采用在报文中添加一个数据分组的序号字段来解决这个问题，对于停等协议，0和1两个标志就足够了，因为我们只需要区分目前</p>
<p><strong>发送方</strong>：</p>
<p>1.AL调用rdt_send()，TL发送0号分组给NL，转入等待接收方控制报文状态。</p>
<p>3.如果收到控制报文，发现或者分组损坏或者是NAK，则重传0号分组，发现是ACK，则等待AL准备好1号分组。</p>
<p>4.AL调用rdt_send()，TL发送1号分组给NL，转入等待接收方控制报文状态。</p>
<p>6.如果收到控制报文，发现或者分组损坏或者是NAK，则重传1号分组，发现是ACK，则等待AL准备好0号分组。</p>
<p><strong>接收方</strong>：</p>
<p>2.等待发送方的0号分组，NL收到后发给TL，TL检验后若有错，传回NAK，若没错，并且是0号分组，传回ACK，进入等待1号报文的状态。</p>
<p>5.等待发送方的1号分组，NL收到后发给TL，TL检验后若有错，传回NAK。若没错，并且是0号分组，证明第2步发送的ACK报文损坏，导致发送方重传0号分组，现在只需要传回ACK，再接着等待1号分组就可以了。若没错，并且是1号分组，则传回ACK，进入等待0号报文的状态。</p>
<h3 id="rdt-22">RDT 2.2</h3>
<p>其实NAK控制报文也是不需要的，假设接收方已经确认了0号报文，发回了ACK0，然后接受1号报文时发现了报文损坏，则再次发回ACK0，发送方收到两个ACK0，就知道接收方没有正确收到0号报文之后的报文，这就是RDT 2.2相对于2.1的改进。</p>
<p><strong>发送方</strong>：</p>
<p>1.AL调用rdt_send()，TL发送0号分组给NL，转入等待接收方控制报文状态。</p>
<p>3.如果收到控制报文，发现或者分组损坏或者是ACK1，则重传0号分组，发现是ACK0，则等待AL准备好1号分组。</p>
<p>4.AL调用rdt_send()，TL发送1号分组给NL，转入等待接收方控制报文状态。</p>
<p>6.如果收到控制报文，发现或者分组损坏或者是ACK0，则重传1号分组，发现是ACK1，则等待AL准备好0号分组。</p>
<p><strong>接收方</strong>：</p>
<p>2.等待发送方的0号分组，NL收到后发给TL，TL检验后若有错或者是1号分组，则传回ACK1，并继续等待0号分组。若没错并且是0号分组，则发送ACK0，进入等待1号分组的状态。</p>
<p>5.如果收到控制报文，若发现分组损坏，则返回ACK0（要求重传1号分组），若发现是0号分组（证明上次ACK0传输出错，发送方重传0号分组），则返回ACK0，继续等待1号分组。若发现是1号分组，传回ACK1，进入等待0号分组的状态。</p>
<h2 id="rdt-30">RDT 3.0</h2>
<p>RDT 3.0假设信道不仅会出错，还会出现丢包。</p>
<p>RDT 3.0让发送方负责检测和解决丢包，假设发送方发送了一个分组，该分组或者接收方的ACK发生了丢包，这两种情况下发送方都收不到任何响应，如果发送方等待了足够长的时间并确定分组已经丢失，则只需要重传该分组即可。如果等待时间设置错误（过短），导致的冗余分组的处理方法RDT 2.2已经涉及，即采用分组序号。</p>
<p>在RDT 3.0中，为了实现基于时间的重传机制，设置了一个倒数定时器，在规定的时间过后会中断发送方。发送方需要做到：</p>
<ol>
<li>每次发送一个分组时，启动一个定时器。</li>
<li>采取适当的动作响应定时器中断。</li>
<li>当分组确认后，终止定时器。</li>
</ol>
<p>相较于RDT 2.2，RDT3.0的变化就是发送方发送分组后启动定时器，等待ACK时若定时器超时就重传并重启定时器，若收到正确的ACK就关闭定时器。</p>
<h2 id="流水线rdt">流水线RDT</h2>
<p>由于上面涉及到的RDT是一个串行的停等协议，对于通信链路的利用率低的可怕，因此可以对发送方进行流水线化改造，即允许发送方在收到上一个分组的ACK之前就发送下一个分组，为了进行多个分组的同时传输，现在有必要为每个分组指定唯一的分组序号，同时发送方和接收方要可以缓存多个分组。有两种可以解决流水线错误的协议。</p>
<h3 id="回退n步协议go-back-n-stepsgbn">回退N步协议（Go Back N-Steps，GBN）</h3>
<p>事实上就是滑窗法，发送方维护一个当前发送分组的窗口，如果n号分组和之前的分组全部确认，接收方才返回ACKn信号，只要发生乱序（提前收到之后的分组，我要5号你给我6号）直接丢弃分组，并返回最后一个有序的分组n的ACKn，然后发送方重传n+1号及之后的分组，这种确认方法被称为累积确认。</p>
<h3 id="选择重传selective-repeatsr">选择重传（Selective Repeat，SR）</h3>
<p>在GBN中，单个分组的出错就能引起大量重传，事实上很多分组没有必要重传，这样做就造成了性能下降。SR的做法是在接收方也维护一个窗口，
窗口的左端点是顺序接收的最后一个分组的下一个，只要在窗口范围内的分组，哪怕失序到达也可以先缓存好。</p>
<h1 id="传输控制协议tcp工作方式">传输控制协议（TCP）工作方式</h1>
<p>在保证数据可靠传输方面，TCP的基本原理和上述RDT一致，下面就流量控制，拥塞控制和连接管理等方面来讨论TCP协议。</p>
<h2 id="流量控制">流量控制</h2>
<p>一条TCP链接的每侧主机都为该链接设置了缓存，如果发送方发送数据太快而接收方读取缓存数据太慢（比如接收方正在忙别的）
就会导致接收方缓存溢出，流量控制机制即为解决这个问题而诞生。事实上流量控制是一个速度匹配服务。</p>
<p>流量控制依靠在TCP报文中加入对本机的剩余缓存量实现。最终达到互相通知缓存剩余量的目的。</p>
<h2 id="连接管理">连接管理</h2>
<p>这里讨论了建立和拆除一条TCP连接时发生的事情。三次握手四次挥手的详细步骤见《自顶向下》。</p>
<p>下面引用了<a href="https://www.zhihu.com/question/24853633/answer/115173386">知乎上的一个回答</a></p>
<blockquote>
<p>TCP可靠传输的精髓： TCP连接的一方A，由操作系统动态随机选取一个32位长的序列号(Initial Sequence Number)，假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001, 1002，1003..... 并把自己的初始序列号ISN告诉B，让B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。</p>
</blockquote>
<blockquote>
<p>同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001， 2002， 2003.... 并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001,则意味着字节编号为2001-4000,共2000个字节已经安全到达。</p>
</blockquote>
<blockquote>
<p>一句话概括，TCP连接握手，握的就是通信双方数据原点的序列号!</p>
</blockquote>
<h2 id="拥塞控制">拥塞控制</h2>
<p>总地来说，拥塞是由于发送速率过快，中间路由器缓存或者通信链路容量不足而导致的丢包。</p>
]]></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://keiksy.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</category>
                                
                            
                                
                                
                                
                                    <category domain="https://keiksy.me/categories/%E7%BD%91%E7%BB%9C/">网络</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://keiksy.me/tags/%E6%80%BB%E7%BB%93/">总结</category>
                                
                            
                        
                    
                
            </item>
        
    </channel>
</rss>
